"""Add taskruleno primary key to task_rules, keep unique(taskno, rule)

Revision ID: a1b2c3d4e5f6
Revises: 9f3a8c2f1b23
Create Date: 2025-08-23 00:00:00.000000

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision: str = 'a1b2c3d4e5f6'
down_revision: Union[str, Sequence[str], None] = '9f3a8c2f1b23'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # Add surrogate PK
    op.add_column('task_rules', sa.Column('taskruleno', sa.Integer(), nullable=True))
    # Backfill new PK incrementally
    op.execute("""
        WITH numbered AS (
            SELECT row_number() OVER (ORDER BY taskno, rule) AS rn, taskno, rule
            FROM task_rules
        )
        UPDATE task_rules t
        SET taskruleno = numbered.rn
        FROM numbered
        WHERE t.taskno = numbered.taskno AND t.rule = numbered.rule
    """)
    # Set not null first (required before adding identity on some PG versions)
    op.alter_column('task_rules', 'taskruleno', nullable=False)
    # Ensure column has identity for future inserts (PostgreSQL 10+)
    op.execute("ALTER TABLE task_rules ALTER COLUMN taskruleno ADD GENERATED BY DEFAULT AS IDENTITY")
    # Drop existing composite PK before creating the new PK
    op.drop_constraint('task_rules_pkey', 'task_rules', type_='primary')
    # Create new PK
    op.create_primary_key('pk_task_rules', 'task_rules', ['taskruleno'])
    # Add unique constraint on (taskno, rule)
    op.create_unique_constraint('uq_task_rules_taskno_rule', 'task_rules', ['taskno', 'rule'])


def downgrade() -> None:
    # Drop unique constraint and PK, then drop column
    op.drop_constraint('uq_task_rules_taskno_rule', 'task_rules', type_='unique')
    op.drop_constraint('pk_task_rules', 'task_rules', type_='primary')
    op.drop_column('task_rules', 'taskruleno')
